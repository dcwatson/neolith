<html>
    <head>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
        <style>
        </style>
    </head>
    <body>
        <div id="app">
            <v-app dark>
                <v-content>
                    <v-container fluid fill-height>
                        <v-layout align-center justify-center>
                            <v-flex xs12 sm8 md4>
                                <v-form method="post" id="signupForm" v-model="valid">
                                    <v-card class="elevation-12">
                                        <v-toolbar>
                                            <v-toolbar-title>{{ server_name }} Signup</v-toolbar-title>
                                        </v-toolbar>
                                        <v-card-text>
                                            <v-text-field prepend-icon="person" name="username" label="Username" type="text" :rules="usernameRules" v-model="username"></v-text-field>
                                            <v-text-field prepend-icon="lock" label="Password" type="password" :rules="passwordRules" v-model="password"></v-text-field>
                                            <v-text-field prepend-icon="lock" label="Verify Password" type="password" :error-messages="verifyError" v-model="confirm"></v-text-field>
                                            <v-text-field prepend-icon="email" name="email" label="Email Address" type="email" :rules="emailRules" v-model="email"></v-text-field>
                                        </v-card-text>
                                        <v-card-actions>
                                            <template v-if="status">
                                                <v-progress-circular indeterminate :size="20" :width="3" class="mx-2"></v-progress-circular>
                                                {% raw %}{{ status }}{% endraw %}&hellip;
                                            </template>
                                            <v-spacer></v-spacer>
                                            <v-btn color="primary" @click="submit" :disabled2="!valid">Signup</v-btn>
                                        </v-card-actions>
                                    </v-card>
                                </v-form>
                            </v-flex>
                        </v-layout>
                    </v-container>
                </v-content>
            </v-app>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/vue-resource@1.5.1"></script>
        <script>
            function b64encode(buf) {
                return btoa(String.fromCharCode.apply(null, new Uint8Array(buf)));
            }
            function b64decode(s) {
                // https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
                var bs = atob(s), buf = new Uint8Array(bs.length);
                Array.prototype.forEach.call(buf, function (el, idx, arr) { arr[idx] = bs.charCodeAt(idx); });
                return buf;
            }
            async function generateKeys(username, password, email) {
                var pwBytes = new TextEncoder('UTF-8').encode(password);
                var iterations = 200000;
                var passwordSalt = window.crypto.getRandomValues(new Uint8Array(32));
                // ECDH
                var ecdhSalt = window.crypto.getRandomValues(new Uint8Array(32));
                var ecdhNonce = window.crypto.getRandomValues(new Uint8Array(12));
                var ecdhKeys = await window.crypto.subtle.generateKey({name: "ECDH", namedCurve: "P-384"}, true, ["deriveKey", "deriveBits"]);
                var ecdhPublic = await window.crypto.subtle.exportKey("raw", ecdhKeys.publicKey);
                var ecdhPrivate = await window.crypto.subtle.exportKey("pkcs8", ecdhKeys.privateKey);
                // ECDSA
                var ecdsaSalt = window.crypto.getRandomValues(new Uint8Array(32));
                var ecdsaNonce = window.crypto.getRandomValues(new Uint8Array(12));
                var ecdsaKeys = await window.crypto.subtle.generateKey({name: "ECDSA", namedCurve: "P-384"}, true, ["sign", "verify"]);
                var ecdsaPublic = await window.crypto.subtle.exportKey("raw", ecdsaKeys.publicKey);
                var ecdsaPrivate = await window.crypto.subtle.exportKey("pkcs8", ecdsaKeys.privateKey);
                // Import the password as a key, so we can run it through PBKDF2 to generate an AES-GCM key.
                var pwKey = await window.crypto.subtle.importKey("raw", pwBytes, {name: "PBKDF2"}, false, ["deriveBits"]);
                // Generate a PBKDF2 digest of the password. This will be what the server stores, and what clients send at login.
                var pwHash = await window.crypto.subtle.deriveBits({name: "PBKDF2", salt: passwordSalt, iterations: iterations, hash: "SHA-256"}, pwKey, 256);
                // Generate a separate PBKDF2 digest of the password with a different salt. This will be used as an AES-GCM key for encrypting the ECDH private key.
                var ecdhHash = await window.crypto.subtle.deriveBits({name: "PBKDF2", salt: ecdhSalt, iterations: iterations, hash: "SHA-256"}, pwKey, 256);
                var ecdhAesKey = await window.crypto.subtle.importKey("raw", ecdhHash, "AES-GCM", false, ["encrypt"]);
                var ecdhPrivateEncrypted = await window.crypto.subtle.encrypt({name: "AES-GCM", iv: ecdhNonce, tagLength: 128}, ecdhAesKey, ecdhPrivate);
                // Generate a separate PBKDF2 digest of the password with a different salt. This will be used as an AES-GCM key for encrypting the ECDSA private key.
                var ecdsaHash = await window.crypto.subtle.deriveBits({name: "PBKDF2", salt: ecdsaSalt, iterations: iterations, hash: "SHA-256"}, pwKey, 256);
                var ecdsaAesKey = await window.crypto.subtle.importKey("raw", ecdsaHash, "AES-GCM", false, ["encrypt"]);
                var ecdsaPrivateEncrypted = await window.crypto.subtle.encrypt({name: "AES-GCM", iv: ecdsaNonce, tagLength: 128}, ecdsaAesKey, ecdsaPrivate);
                return {
                    username: username.toLowerCase(),
                    email: email.toLowerCase(),
                    password: b64encode(pwHash),
                    password_spec: {
                        algorithm: "pbkdf2_sha256",
                        salt: b64encode(passwordSalt),
                        iterations: iterations
                    },
                    ecdh: {
                        salt: b64encode(ecdhSalt),
                        iterations: iterations,
                        nonce: b64encode(ecdhNonce),
                        data: b64encode(ecdhPrivateEncrypted),
                        public_key: b64encode(ecdhPublic)
                    },
                    ecdsa: {
                        salt: b64encode(ecdsaSalt),
                        iterations: iterations,
                        nonce: b64encode(ecdsaNonce),
                        data: b64encode(ecdsaPrivateEncrypted),
                        public_key: b64encode(ecdsaPublic)
                    }
                };
            }
            var vm = new Vue({
                el: '#app',
                data: {
                    valid: true,
                    status: null,
                    username: '',
                    password: '',
                    confirm: '',
                    email: '',
                    usernameRules: [
                        v => !!v || 'Username is required.',
                    ],
                    passwordRules: [
                        v => !!v || 'Password is required.',
                    ],
                    emailRules: [
                        v => !!v || 'Email address is required.',
                        v => /.+@.+/.test(v) || 'Please enter a valid email address.'
                    ]
                },
                computed: {
                    verifyError: function() {
                        return (this.confirm === this.password) ? '' : 'Passwords do not match.';
                    }
                },
                methods: {
                    submit: async function() {
                        var self = this;
                        this.status = "Generating keys";
                        var data = await generateKeys(this.username, this.password, this.email);
                        this.status = "Signing up"
                        this.$http.post('/signup', JSON.stringify(data)).then(function(response) {
                            if (response.ok) {
                                if (response.body.error) {
                                    console.log(response);
                                }
                                else {
                                    window.location.href = response.body.redirect;
                                }
                            }
                            self.status = null;
                        });
                    }
                }
            });
        </script>
    </body>
</html>
